configured components in VM
route53 with IP address

1. traffic
2. self healing
3. load balancing

autoscaling
launch templates
target groups
load balancers

1. we have a docker host where all containers are running
	what if docker host crash? we lose all containers
	even we use docker volumes, data is still in the host, so we lost data as well
2. what if traffic increases/decreases? are our containers scalable
3. even we have multiple containers to balance the load? who is the LB here?
4. what if some container crashes? can docker make it available again?
5. what about configurations and secrets? where to store them?
6. what if we have multiple hosts running with containers

we need some orchestrator?

kubernetes is popular container orchestration tool. 

docker is used for building the images...it can also run containers but have lot of above disadvantages..

minikube --> it is a single node cluster.. master and node is same. it is just to practice few k8 resources.

kubeconfig --> is the files contains authentication information to connect kubernetes cluster

kubectl automatically search for this directory ".kube/config" inside this we have this kubeconfig file.

To connect minikube master form client server(work station)
-----------------------------------------------------------
install kubectl inclient server.

google it for installation document.

copy authentication file from master and add it in client server. path .kube/config

aws we have multiple resources. like same we have some resources in Kubernetes as well.

rolling update: If you change image to 1.1 → Rolling update happens automatically

Kubernetes resources [in Kubernetes every resource can be written in yaml language that called manifest files]
--------------------
Namespaces ---> it is a project name like our roboshop. inside that roboshop project we have all components. namespace used to create own projects names.
pod --->
Deployment ---> A Deployment is a controller that manages a collection of Pods. Deployment = Pod Manager
configmap ---> it is a configuration store.  


pod
---
pod is a smallest deployable unit. it contains space to run the application like container. and pod contains multiple containers.

* containers in same pod can share the network. like nginx container and almalinux with [sleep 300] example. 
* main difference b/w pod and container is in docker containers not to share same n/w have different private ips. but in pod container have same private ips can share each other. and also in pod container share volumes also.

why pod contains multiple containers
------------------------------------
* there is a main container and another is sidecar to help for main container. Here catalogue container generates too many to log files right. the sidecar takes that log files push to ELK.

basic pod definition:

apiVersion: v1
kind: Pod
metadata:
  name: nginx
  namespace: roboshop  # create pod in roboshop namespace, make sure to create namespace before run the pod.	
spec:
  containers:          # Fixed: "container" → "containers" (plural)
  - name: nginx        # Fixed: List format with "-"
    image: nginx
    ports:
    - containerPort: 80  # Fixed: Indentation (2 spaces)


services
---------
**No, Service is NOT like an EC2 Security Group.** They're completely different concepts.

## Kubernetes Service vs EC2 Security Group

| **Kubernetes Service**                | **EC2 Security Group**                |
|---------------------------------------|----------------------                 |
| **Load balancer + Service Discovery** | **Firewall rules**                    |
| **Routes traffic TO pods**            | **Controls traffic TO EC2 instances** |
| `<service-name>` → Pod IPs            | Port 80, 443 inbound allowed          |
| **Internal cluster networking**       | **AWS VPC networking**                |

## What Service Actually Does
```yaml
apiVersion: v1
kind: Service
metadata:
  name: frontend-svc
spec:
  selector:
    app: frontend      # Targets frontend pods
  ports:
  - port: 80           # Service port
    targetPort: 8080   # Pod port
```
**Result**: `frontend-svc:80` → any frontend pod:8080 (automatic load balancing)

## Visual Flow
```
Browser → frontend-svc:80 → Pod1:8080
                       ↔ Pod2:8080  
                       ↔ Pod3:8080
```

## EC2 Security Group Analogy (Wrong)
```
❌ WRONG: Service = Firewall
✅ CORRECT: Service = Internal Load Balancer + DNS
```

## Roboshop Example
```yaml
# Deployment creates 3 frontend pods
apiVersion: apps/v1
kind: Deployment
spec:
  replicas: 3

---
# Service gives single stable endpoint
apiVersion: v1
kind: Service  
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
```
**Access**: `frontend-service.roboshop.svc.cluster.local` (not individual pod IPs)

## Real Security in Kubernetes
```
# NetworkPolicy (actual Kubernetes firewall)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
spec:
  podSelector: {}           # Like Security Group rules
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: backend      # Only backend → frontend
```

**Service = Networking Layer 7 (load balancing)**  
**Security Group = Networking Layer 4 (firewall)**

labels:
-------
labels:
  Enploye: Mahesh
  experience: 0.2

labels are always in key-value pair. used to attach another resources also. like we already have running a pod so how we attach it to service. so through the label we can attach.


commands
--------
kubectl create -f <pod.yaml> --> create pod and also run same command second will get and error if pod exist.

kubectl apply -f <pod.yaml> --> creating a pod and make it running. here no error if run second time if file have changes will update otherwise showing unchanged.

kubectl get pods --> display running pods

kubectl describe pod <pod_name> = Docker inspect

kubectl delete -f yamlfile.yaml --> delete the resources

kubectl get namespaces --> will get all namespaces in cluster

kubectl get nodes

kubectl exec -it <pod_name> -- bash ---> login into pod like docker container.


labels vs annotaions
--------------------
labels --> have some limitation on the length and charecters of key and values
annotaions --> no limit on length and special charecters also can be used...

labels are used to select other kubernetes resources.
annotaions are used to select external resources to kubernetes. in annotation we can give external urls also.

env
---
assign environment variables inside the container.
always assign env inside the spec block. that means assign it to container.

resouces:
---------
the resources block is used to limit the container usage. like cpu, memory.
 resources:
      requests:
        cpu: "100m"
        memory: "68Mi"
      limits:
        cpu: "200m"
        memory: "128Mi"



class-2
-------

ephemeral = dynamic, it means pod is dynamically changes so it's ip also changing.

workstation --> Kubernetes master ---> work nodes

nodegroups --> means we manage the nodes.

maanagesNodeGroups --> completely aws can manage.

To create cluster:
------------------
aws configure ---> 
eksctl create cluster --config-file=eksctl.yaml

base64
------
echo -n "admin" | base64
echo -n "admin" | base64 --decode

configmap
---------
configmap is also a resource used to store the insensitive values.

secrets 
--------
to secrets values in encoded format.

services
--------
very important concept in k8s.

user--->service---->pod

1. service is used to expose application to outside.
2. and also used for load balanceing.
3. service mesh is like ALB in aws. request comes to service mesh and service mesh requests go to pods.

inside service we have
----------------------
Cluster IP ---> within the Kubernetes not expose to internet.
node port ---> expose to outside the world
loadbalancing ---> expose to outside the world. only work in cloud providers.


Services is like route53 records. ip changes but name not change. here service IP can change but name not change. name is like DNS.

pod is subset of Replicaset.

Replicaset is only for maintain number of replicas. it don't have capable of new version update.

note this:
---------
pod < clusterip < nodeport < LB

pod < replicaset < Deployment

Rolling update: create new replicaset and new pod created then old pod terminated. same scenario follows upto all new pod up. based on application few there will run old version and new version. without effecting the users.

kubectl get deployments -n roboshop --> get deployments in particular namespace

kubectl get pods -o wide ---> to see pods that are present in which node.

kubens: ---> it sets the default namespace

filebeat (sidecar) ---> agent to access logs and push to elk.











































































