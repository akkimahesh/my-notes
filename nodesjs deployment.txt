
Note: /var/www: ---> this path refers to applicaton. make sure to run application from this directory.

You said:
deploy nodejs application on dev, qa, prod on same ec2 with pm2 installation and route through nginx add SSL using certbot

ChatGPT said:
Good ğŸ”¥ This is a very common real-world DevOps setup.

You want:

âœ… Same EC2 instance

âœ… 3 environments â†’ dev, qa, prod

âœ… Node.js app managed by PM2

âœ… Nginx reverse proxy

âœ… SSL using Certbot

Iâ€™ll give you a clean production-grade setup step-by-step.

ğŸ—ï¸ Architecture Overview
Internet
   â†“
Nginx (80/443)
   â†“
PM2 Processes (Different Ports)
   â†“
Node.js Apps
Each environment runs on a different port:

Environment	Port
DEV	3001
QA	3002
PROD	3003
âœ… STEP 1 â€” Install Required Software
SSH into EC2:

sudo apt update -y
sudo apt install nginx -y
sudo apt install certbot python3-certbot-nginx -y
sudo apt install nodejs npm -y
sudo npm install -g pm2
Verify:

nginx -v
node -v
pm2 -v
âœ… STEP 2 â€” Project Structure (Recommended)
/var/www/
    â”œâ”€â”€ app-dev
    â”œâ”€â”€ app-qa
    â””â”€â”€ app-prod
Create directories:

sudo mkdir -p /var/www/app-dev
sudo mkdir -p /var/www/app-qa
sudo mkdir -p /var/www/app-prod
Clone your repo into each folder.

âœ… STEP 3 â€” Configure Environment Ports
In your Node app (example: server.js):

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
âœ… STEP 4 â€” Start with PM2
Go to each folder:

DEV
cd /var/www/app-dev
npm install
PORT=3001 pm2 start server.js --name app-dev
QA
cd /var/www/app-qa
npm install
PORT=3002 pm2 start server.js --name app-qa
PROD
cd /var/www/app-prod
npm install
PORT=3003 pm2 start server.js --name app-prod
Save PM2:

pm2 save
pm2 startup
âœ… STEP 5 â€” Configure Nginx Reverse Proxy
Create nginx config:

sudo nano /etc/nginx/sites-available/app
ğŸ”¹ If using Subdomains (Recommended)
Example:

dev.yourdomain.com

qa.yourdomain.com

yourdomain.com (prod)

Paste:

server {
    server_name dev.yourdomain.com;

    location / {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
    }
}

server {
    server_name qa.yourdomain.com;

    location / {
        proxy_pass http://localhost:3002;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
    }
}

server {
    server_name yourdomain.com;

    location / {
        proxy_pass http://localhost:3003;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
    }
}
Enable it:

sudo ln -s /etc/nginx/sites-available/app /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl restart nginx
âœ… STEP 6 â€” Configure SSL (Certbot)
Make sure DNS points to EC2 public IP.

Run:

sudo certbot --nginx -d dev.yourdomain.com -d qa.yourdomain.com -d yourdomain.com
Certbot will:

Automatically configure SSL

Redirect HTTP â†’ HTTPS

Test auto renewal:

sudo certbot renew --dry-run
ğŸ¯ Final Setup
Now:

URL	Environment
https://dev.yourdomain.com	DEV
https://qa.yourdomain.com	QA
https://yourdomain.com	PROD
ğŸ§  Best Practice (Production Level Improvement)
Instead of manually setting PORT, use PM2 ecosystem file:

Create ecosystem.config.js:

module.exports = {
  apps: [
    {
      name: "app-dev",
      script: "server.js",
      cwd: "/var/www/app-dev",
      env: { PORT: 3001 }
    },
    {
      name: "app-qa",
      script: "server.js",
      cwd: "/var/www/app-qa",
      env: { PORT: 3002 }
    },
    {
      name: "app-prod",
      script: "server.js",
      cwd: "/var/www/app-prod",
      env: { PORT: 3003 }
    }
  ]
};
Start:

pm2 start ecosystem.config.js
pm2 save
âš ï¸ Important Production Warnings
Running dev, qa, prod on same EC2:

âœ” Cheap
âŒ Not fully isolated
âŒ If EC2 crashes â†’ all environments down

For learning or small startup â†’ OK
For enterprise â†’ separate EC2 or containers

If you want, I can next explain:

ğŸ”¥ How to automate this with Jenkins pipeline

ğŸ”¥ How to auto deploy dev/qa/prod from different branches

ğŸ”¥ How to do blue-green deployment

ğŸ”¥ How to dockerize this properly

Tell me which one you want ğŸš€


You said:
pm2 start ecosystem.config.js
if i run this 3 applicaton created ..?

ChatGPT said:
Yes âœ… â€” if your ecosystem.config.js contains 3 apps, then:

pm2 start ecosystem.config.js
ğŸ‘‰ PM2 will create and start all 3 applications.

ğŸ” Example
If your file looks like this:

module.exports = {
  apps: [
    {
      name: "app-dev",
      script: "server.js",
      cwd: "/var/www/app-dev",
      env: { PORT: 3001 }
    },
    {
      name: "app-qa",
      script: "server.js",
      cwd: "/var/www/app-qa",
      env: { PORT: 3002 }
    },
    {
      name: "app-prod",
      script: "server.js",
      cwd: "/var/www/app-prod",
      env: { PORT: 3003 }
    }
  ]
};
Then running:

pm2 start ecosystem.config.js
Will result in:

pm2 list
Output like:

â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ id  â”‚ name      â”‚ status â”‚ cpu    â”‚ mem  â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0   â”‚ app-dev   â”‚ online â”‚ 0%     â”‚ 50mb â”‚
â”‚ 1   â”‚ app-qa    â”‚ online â”‚ 0%     â”‚ 50mb â”‚
â”‚ 2   â”‚ app-prod  â”‚ online â”‚ 0%     â”‚ 60mb â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
So yes â€” 3 apps will be created and started ğŸš€

âš ï¸ Important Things to Know
1ï¸âƒ£ If you run it again?
If they already exist, PM2 may:

Throw error

Or restart them (depending on flags)

Better way:

pm2 restart ecosystem.config.js
or

pm2 reload ecosystem.config.js
2ï¸âƒ£ If you want only one app
pm2 start ecosystem.config.js --only app-dev
3ï¸âƒ£ To delete all 3 apps
pm2 delete all
4ï¸âƒ£ Save for auto-start after reboot
pm2 save
pm2 startup
ğŸ¯ Best Practice (Production)
Instead of pm2 start, use:

pm2 start ecosystem.config.js --env production
If you define different env blocks.

If you want, I can now explain:

Difference between restart and reload

Zero-downtime reload

Cluster mode in PM2

Memory limit auto-restart feature

Which one you want next? ğŸš€


You said:
then where i can cofigure this inside nodejs application or somewhere else

ChatGPT said:
Good question ğŸ‘ This is where many people get confused.

Short answer:

ğŸ‘‰ Environment configuration should NOT be hardcoded inside your Node.js app.
ğŸ‘‰ It should be controlled from PM2 (ecosystem file) or .env files.

âœ… Correct Architecture
ğŸ”¹ Node.js App â†’ Generic
ğŸ”¹ Environment Values â†’ Controlled externally
Your Node.js app should look like this:

const port = process.env.PORT || 3000;

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
Notice:
âŒ No 3001 / 3002 / 3003 hardcoded
âœ… Using process.env.PORT

ğŸ¯ Where Should You Configure Environment?
You have 3 clean options:

ğŸ¥‡ OPTION 1 â€” Configure Inside ecosystem.config.js (Best for Your Setup)
module.exports = {
  apps: [
    {
      name: "app-dev",
      script: "server.js",
      cwd: "/var/www/app-dev",
      env: {
        PORT: 3001,
        NODE_ENV: "development"
      }
    },
    {
      name: "app-qa",
      script: "server.js",
      cwd: "/var/www/app-qa",
      env: {
        PORT: 3002,
        NODE_ENV: "qa"
      }
    },
    {
      name: "app-prod",
      script: "server.js",
      cwd: "/var/www/app-prod",
      env: {
        PORT: 3003,
        NODE_ENV: "production"
      }
    }
  ]
};
Then:

pm2 start ecosystem.config.js
âœ” Clean
âœ” Centralized
âœ” Production-friendly

ğŸ¥ˆ OPTION 2 â€” Use .env File (Very Common in Real Projects)
Inside each folder:

/var/www/app-dev/.env
PORT=3001
NODE_ENV=development
/var/www/app-qa/.env
PORT=3002
NODE_ENV=qa
/var/www/app-prod/.env
PORT=3003
NODE_ENV=production
Install dotenv:

npm install dotenv
In your server.js:

require('dotenv').config();

const port = process.env.PORT || 3000;
âœ” Cleaner separation
âœ” Easy for CI/CD
âœ” Very popular method

ğŸ¥‰ OPTION 3 â€” Pass While Starting (Not Recommended for Production)
PORT=3001 pm2 start server.js --name app-dev
This works, but not clean for long-term.

ğŸš€ What I Recommend For You
Since you're:

Running 3 environments on same EC2

Using PM2

Using Nginx

ğŸ‘‰ Best choice = ecosystem.config.js + NODE_ENV + PORT

Because:

Central control

Easy restart

Easy CI/CD integration

Professional setup

ğŸ”¥ Professional Level Tip
Inside ecosystem file you can also configure:

instances: "max",
exec_mode: "cluster",
max_memory_restart: "300M",
Example (prod only):

{
  name: "app-prod",
  script: "server.js",
  cwd: "/var/www/app-prod",
  instances: "max",
  exec_mode: "cluster",
  max_memory_restart: "500M",
  env: {
    PORT: 3003,
    NODE_ENV: "production"
  }
}
Now it's production-ready ğŸ”¥

ğŸ§  Final Clear Answer
ğŸ‘‰ Configure environment variables in:

ecosystem.config.js (best for you)
OR

.env file (common industry method)

ğŸ‘‰ Keep Node.js app generic using process.env.

If you want next, I can explain:

How to connect different databases for dev/qa/prod

How to auto deploy each environment from different Git branches

How to secure .env files properly

Tell me what you want ğŸš€


You said:
i understand this, but where i can keep this file inside nodejs applicaton folder or else outside?

ChatGPT said:
Very good question ğŸ‘Œ â€” this is real DevOps thinking.

âœ… Short Answer
ğŸ‘‰ Keep ecosystem.config.js OUTSIDE individual environment folders.
ğŸ‘‰ Place it in a central location (example: /var/www/).

ğŸ¯ Best Practice for Your Setup (Same EC2, 3 Environments)
Since you have:

/var/www/
    â”œâ”€â”€ app-dev
    â”œâ”€â”€ app-qa
    â”œâ”€â”€ app-prod
âœ… Recommended Structure:
/var/www/
    â”œâ”€â”€ app-dev/
    â”œâ”€â”€ app-qa/
    â”œâ”€â”€ app-prod/
    â””â”€â”€ ecosystem.config.js   ğŸ‘ˆ HERE
ğŸš€ Why Outside?
Because:

âœ” It manages multiple applications
âœ” It is infrastructure-level config
âœ” Itâ€™s not part of a single app
âœ” Cleaner separation of concerns

Think like this:

Node app â†’ application code

ecosystem file â†’ process manager config (infra)

ğŸ”¥ How You Run It
From /var/www:

pm2 start ecosystem.config.js
PM2 will look inside each cwd:

cwd: "/var/www/app-dev"
ğŸ§  When Should You Keep It Inside the App Folder?
Only when:

You have single app

OR each environment is on separate server

OR using CI/CD per environment

Example:

app/
 â”œâ”€â”€ server.js
 â”œâ”€â”€ package.json
 â””â”€â”€ ecosystem.config.js
That is common in Docker or separate EC2 setups.

ğŸ† Professional Recommendation (For You)
Since you're running:

Dev

QA

Prod

Same EC2

ğŸ‘‰ Keep ecosystem file in /var/www/

Clean.
Professional.
Maintainable.

âš¡ Bonus Tip (Very Important)
Make sure permissions are correct:

sudo chown -R ubuntu:ubuntu /var/www
Otherwise PM2 may throw permission errors.

If you want, next I can show:

How to auto deploy dev/qa/prod using Jenkins branches

OR how to structure this properly for enterprise level

Your DevOps skills improving fast ğŸ”¥




git pull error comes like below
-------------------------------

error: Your local changes to the following files would be overwritten:
vendor/_reset_log.txt
Please commit your changes or stash them before you switch branches.

use below commands:
git stash 
git pull

then, 
pm2 list 
pm2 restart <application_name> ---> automatically application restart with changes

if your using pm2 run below command zero  down time if application updated with new version
-------------------------------------------------------------------------------------------
- name: Install dependencies & reload app
      cd /var/www/scutiarts
      npm install --production
      pm2 reload Scutiarts-dev || pm2 start server.js --name Scutiarts-dev --env production
      pm2 save


 npx serve . --> to run locally




